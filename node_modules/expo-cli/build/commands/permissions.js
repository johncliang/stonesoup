"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.actionAndroid = actionAndroid;
exports.actionIOS = actionIOS;
exports.default = void 0;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _StandaloneContext() {
  const data = _interopRequireDefault(require("@expo/xdl/build/detach/StandaloneContext"));

  _StandaloneContext = function () {
    return data;
  };

  return data;
}

function Manifest() {
  const data = _interopRequireWildcard(require("@expo/android-manifest"));

  Manifest = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _enquirer() {
  const data = require("enquirer");

  _enquirer = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-ignore: MultiSelect is not typed
const DefaultiOSPermissions = {
  NSCalendarsUsageDescription: `Allow $(PRODUCT_NAME) to access your calendar`,
  NSCameraUsageDescription: `Allow $(PRODUCT_NAME) to use the camera`,
  NSContactsUsageDescription: `Allow $(PRODUCT_NAME) experiences to access your contacts`,
  NSLocationAlwaysUsageDescription: `Allow $(PRODUCT_NAME) to use your location`,
  NSLocationAlwaysAndWhenInUseUsageDescription: `Allow $(PRODUCT_NAME) to use your location`,
  NSLocationWhenInUseUsageDescription: `Allow $(PRODUCT_NAME) experiences to use your location`,
  NSMicrophoneUsageDescription: `Allow $(PRODUCT_NAME) to access your microphone`,
  NSMotionUsageDescription: `Allow $(PRODUCT_NAME) to access your device's accelerometer`,
  NSPhotoLibraryAddUsageDescription: `Give $(PRODUCT_NAME) experiences permission to save photos`,
  NSPhotoLibraryUsageDescription: `Give $(PRODUCT_NAME) experiences permission to access your photos`,
  NSRemindersUsageDescription: `Allow $(PRODUCT_NAME) to access your reminders`
};
const DefaultiOSPermissionNames = {
  NSCalendarsUsageDescription: `Calendars`,
  NSCameraUsageDescription: `Camera`,
  NSContactsUsageDescription: `Contacts`,
  NSLocationAlwaysUsageDescription: `Always location`,
  NSLocationAlwaysAndWhenInUseUsageDescription: `Always location and when in use`,
  NSLocationWhenInUseUsageDescription: `Location when in use`,
  NSMicrophoneUsageDescription: `Microphone`,
  NSMotionUsageDescription: `Motion`,
  NSPhotoLibraryAddUsageDescription: `Saving Photos`,
  NSPhotoLibraryUsageDescription: `Camera Roll`,
  NSRemindersUsageDescription: `Reminders`
};
const CHEVRON = `\u203A`;

async function writePermissionsToIOSAsync(projectDir, {
  ios = {}
}, permissions) {
  console.log(_chalk().default.magenta(`${CHEVRON} Saving selection to the ${_chalk().default.underline`expo.ios.infoPlist`} object in your universal ${_chalk().default.bold`app.json`}...`));
  await (0, _config().writeConfigJsonAsync)(projectDir, {
    ios: { ...ios,
      infoPlist: { ...(ios.infoPlist || {}),
        ...permissions
      }
    }
  });
}

function getPermissionDescription(appName, {
  ios = {}
}, permission) {
  const {
    infoPlist = {}
  } = ios;

  if (typeof infoPlist[permission] === 'string') {
    return infoPlist[permission];
  }

  return getDefaultExpoPermissionDescription(appName, permission);
}

function getDefaultExpoPermissionDescription(appName, permission) {
  // TODO(Bacon): Maybe use name instead of $(PRODUCT_NAME)
  const permissionDescription = DefaultiOSPermissions[permission];

  if (!permissionDescription) {
    throw new Error(`No permission for ${permission}`);
  }

  return permissionDescription;
}

async function getActiveAndroidPermissionsAsync(manifestPath, exp) {
  console.log('');
  let permissions; // The Android Manifest takes priority over the app.json

  if (manifestPath) {
    console.log(_chalk().default.magenta(`${CHEVRON} Getting permissions from the native ${_chalk().default.bold`AndroidManifest.xml`}`));
    const manifest = await Manifest().readAsync(manifestPath);
    permissions = Manifest().getPermissions(manifest); // Remove the required permissions

    permissions = permissions.filter(v => v !== 'android.permission.INTERNET');
  } else {
    console.log(_chalk().default.magenta(`${CHEVRON} Getting permissions from the ${_chalk().default.underline`expo.android.permissions`} array in the universal ${_chalk().default.bold`app.json`}...`));
    permissions = (exp.android || {}).permissions; // If no array is defined then that means all permissions will be used

    if (!Array.isArray(permissions)) {
      console.log(_chalk().default.magenta(`${CHEVRON} ${_chalk().default.underline`expo.android.permissions`} does not exist in the ${_chalk().default.bold`app.json`}, the default value is ${_chalk().default.bold`all permissions`}`));
      permissions = Object.keys(Manifest().UnimodulePermissions);
    }
  } // Ensure the names are formatted correctly


  permissions = permissions.map(permission => Manifest().ensurePermissionNameFormat(permission));
  return permissions;
}

async function actionAndroid(projectDir = './') {
  const {
    exp
  } = await (0, _config().readConfigJsonAsync)(projectDir);
  const manifestPath = await Manifest().getProjectAndroidManifestPathAsync(projectDir);
  const permissions = await getActiveAndroidPermissionsAsync(manifestPath, exp);
  const isExpo = !manifestPath;
  const choices = [];
  const allPermissions = [...new Set([...permissions, ...Object.keys(Manifest().UnimodulePermissions)])];

  for (const permission of allPermissions) {
    choices.push({
      name: permission,
      message: permissions.includes(permission) ? _chalk().default.green(permission) : _chalk().default.gray(permission)
    });
  }

  const prompt = new (_enquirer().MultiSelect)({
    header() {
      const descriptions = {// TODO(Bacon): Add descriptions of what each permission is used for
      };
      return descriptions[Object.keys(Manifest().UnimodulePermissions)[this.index]];
    },

    initial: permissions,
    hint: '(Use <space> to select, <return> to submit, <a> to toggle, <i> to invert the selection)',
    message: `Select Android permissions`,
    choices
  });
  console.log('');
  let answer;

  try {
    answer = await prompt.run();
  } catch (error) {
    console.log(_chalk().default.yellow(`${CHEVRON} Exiting...`));
    return;
  }

  const selectedAll = choices.length === answer.length;
  console.log(_chalk().default.magenta(`${CHEVRON} Saving selection to the ${_chalk().default.underline`expo.android.permissions`} array in the ${_chalk().default.bold`app.json`}...`));

  if (isExpo) {
    if (selectedAll) {
      console.log(_chalk().default.magenta(`${CHEVRON} Expo will default to using all permissions in your project by deleting the ${_chalk().default.underline`expo.android.permissions`} array.`));
    }
  }

  await (0, _config().writeConfigJsonAsync)(projectDir, {
    android: { ...(exp.android || {}),
      // An empty array means no permissions
      // No value means all permissions
      permissions: selectedAll ? undefined : answer.map(permission => {
        if (permission.startsWith('android.permission.')) {
          return permission.split('.').pop();
        }

        return permission;
      })
    }
  });

  if (!isExpo) {
    console.log(_chalk().default.magenta(`${CHEVRON} Saving selection to the native ${_chalk().default.bold`AndroidManifest.xml`}`));
    await Manifest().persistAndroidPermissionsAsync(projectDir, ['android.permission.INTERNET', ...answer]);
  }
}

async function promptForPermissionDescriptionsAsync(choices, hasNativeConfig, currentDescriptions) {
  console.log('');
  const keys = Object.keys(DefaultiOSPermissionNames);
  const prompt = new (_enquirer().Form)({
    name: hasNativeConfig ? 'Native project' : 'Universal project',
    message: 'Modify iOS Permissions',

    header() {
      const permission = keys[this.index];

      if (!currentDescriptions[permission]) {
        return _chalk().default.magenta(`${CHEVRON} Add a description to enable the "${_chalk().default.bold(permission)}" permission in your iOS app`);
      }

      return _chalk().default.magenta(`${CHEVRON} Update the description for the permission "${_chalk().default.bold(permission)}"`);
    },

    choices
  });

  try {
    const answer = await prompt.run(); // Trimming allows users to pass in " " to delete a permission

    for (const key of Object.keys(answer)) {
      answer[key] = answer[key].trim();
    }

    return answer;
  } catch (error) {
    console.log(_chalk().default.yellow(`${CHEVRON} Exiting...`));
    process.exit(0);
  }

  return {};
}

async function actionIOS(projectDir = './') {
  const {
    exp
  } = await (0, _config().readConfigJsonAsync)(projectDir);
  const appName = exp.name;
  const context = await _StandaloneContext().default.createUserContext(projectDir, exp, '');
  const supportingDirectory = getInfoPlistDirectory(context);
  let infoPlist;
  console.log('');
  let currentDescriptions = {};
  let defaultExpoDescriptions = {};

  if (supportingDirectory) {
    console.log(_chalk().default.magenta(`${CHEVRON} Using native ios ${_chalk().default.bold`Info.plist`}`));
    infoPlist = await _xdl().IosPlist.modifyAsync(supportingDirectory, 'Info', infoPlist => infoPlist);

    for (const key of Object.keys(DefaultiOSPermissionNames)) {
      if (key in infoPlist && infoPlist[key]) {
        currentDescriptions[key] = infoPlist[key];
      } else {
        currentDescriptions[key] = '';
      }
    }
  } else {
    if ((exp.ios || {}).infoPlist) {
      console.log(_chalk().default.magenta(`${CHEVRON} Getting permissions from the ${_chalk().default.underline`expo.ios.infoPlist`} object in the universal ${_chalk().default.bold`app.json`}...`));
    } else {
      console.log(_chalk().default.magenta(`${CHEVRON} Showing the default permissions used by ${_chalk().default.bold`Turtle`} to build your project...`));
    }

    defaultExpoDescriptions = Object.keys(DefaultiOSPermissions).reduce((previous, current) => ({ ...previous,
      [current]: getDefaultExpoPermissionDescription(appName, current)
    }), {});
    currentDescriptions = Object.keys(DefaultiOSPermissions).reduce((previous, current) => ({ ...previous,
      [current]: getPermissionDescription(appName, exp, current)
    }), {});
  }

  const choices = [];

  for (const key of Object.keys(currentDescriptions)) {
    choices.push({
      name: key,
      message: DefaultiOSPermissionNames[key],
      initial: currentDescriptions[key]
    });
  }

  const answer = await promptForPermissionDescriptionsAsync(choices, !!supportingDirectory, currentDescriptions);
  const modifiedAnswers = Object.keys(answer).reduce((previous, current) => {
    const permissionDescription = answer[current];

    if (permissionDescription !== defaultExpoDescriptions[current] && permissionDescription) {
      return { ...previous,
        [current]: permissionDescription
      };
    }

    return { ...previous,
      [current]: undefined
    };
  }, {});
  await writePermissionsToIOSAsync(projectDir, exp, modifiedAnswers);

  if (supportingDirectory && infoPlist) {
    console.log(_chalk().default.magenta(`${CHEVRON} Saving selection to the native ${_chalk().default.bold`Info.plist`}...`));
    await _xdl().IosPlist.modifyAsync(supportingDirectory, 'Info', infoPlist => {
      for (const key of Object.keys(answer)) {
        if (answer[key]) {
          infoPlist[key] = answer[key];
        } else {
          delete infoPlist[key];
        }
      }

      return infoPlist;
    });
  } else {
    console.log(`${CHEVRON} ${_chalk().default.bold`Remember:`} ${_chalk().default.reset.dim`Permission messages are a build-time configuration. Your selection will only be available in Standalone, or native builds. You will continue to see the predefined permission dialogs when using your app in the Expo client.`}`);
  }
} // Find the location of the native iOS info.plist if it exists
// TODO(Bacon): Do a deep search for the Info.plist in case the app name was changed


function getInfoPlistDirectory(context) {
  const {
    supportingDirectory
  } = _xdl().IosWorkspace.getPaths(context);

  if (_fsExtra().default.existsSync(_path().default.resolve(supportingDirectory, 'Info.plist'))) {
    return supportingDirectory;
  } else if (_fsExtra().default.existsSync(_path().default.resolve(supportingDirectory, '..', 'Info.plist'))) {
    return _path().default.resolve(supportingDirectory, '..');
  }

  return null;
}

function command(program) {
  program.command('permissions:ios [project-dir]').description('Manage permissions in your native iOS project.').allowOffline().asyncAction(actionIOS);
  program.command('permissions:android [project-dir]').description('Manage permissions in your native Android project.').allowOffline().asyncAction(actionAndroid);
} // @ts-ignore


var _default = command;
exports.default = _default;
//# sourceMappingURL=../__sourcemaps__/commands/permissions.js.map
